<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Business Strategies</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Silkscreen', monospace; }
    #container { position: relative; width: 100vw; height: 100vh; }
    canvas { position:absolute; inset:0; z-index:1; }
    #title {
      position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
      font-size: clamp(32px, 5vw, 48px); font-weight: bold; letter-spacing: -2px;
      text-align: center; pointer-events: none;
      text-shadow: 0 0 8px #ff00ff, 0 0 16px #00ffff, 0 0 24px #ffff00, 0 0 32px #ff00ff;
      filter: drop-shadow(0 0 6px #ff00ff);
      animation: rainbowShift 6s linear infinite;
      z-index: 10;
    }
    #buttons {
      position: absolute; bottom: 96px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 18px; z-index: 10;
    }
    @keyframes rainbowShift {
      0% { color: #ff0000; } 20% { color: #ff00ff; } 40% { color: #00ffff; }
      60% { color: #00ff00; } 80% { color: #ffff00; } 100% { color: #ff0000; }
    }
    .pixel-button {
      font-size: 1.1em;
      font-family: 'Silkscreen', monospace;
      padding: 14px 28px;
      background: #050505;
      color: white;
      cursor: pointer;
      border: 2px solid transparent;
      position: relative;
      text-shadow: 0 0 6px rgba(255,255,255,0.6);
      animation: pixelPulse 2.5s linear infinite;
    }
    .pixel-button::before {
      content: "";
      position: absolute;
      inset: -3px;
      border-radius: 2px;
      background: linear-gradient(90deg, red, magenta, cyan, lime, yellow, red);
      filter: blur(4px);
      opacity: 0.8;
      z-index: -1;
      animation: rainbowTube 3s linear infinite;
    }
    .pixel-button:active { transform: scale(0.9) rotate(-1deg); }
    @keyframes pixelPulse { 0%,100% { filter: brightness(1); } 50% { filter: brightness(1.6); } }
    @keyframes rainbowTube { from { background-position: 0% 50%; } to { background-position: 200% 50%; } }
        #hudWireframe{
      position:absolute;
      top:16px;
      right:16px;
      width:220px;
      height:220px;
      pointer-events:none;
      z-index:15;
    }
  </style>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Silkscreen&display=swap">
  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.164.0/build/three.module.js" } }
  </script>
</head>
<body>
  <div id="container">
    <div id="hudWireframe"></div>
    
    <div id="title">QUANTUM BUSINESS STRATEGIES</div>
    <div id="buttons">
      <button class="pixel-button" data-action="apply">APPLY</button>
      <button class="pixel-button" data-action="why">WHY</button>
      <button class="pixel-button" data-action="incorporate">INCORPORATE</button>
    </div>
  </div>

  <script type="module">
import * as THREE from 'three';

/* ================= PERF-FIRST CLEAN BASELINE =================
   Visual output preserved â€” allocations & overdraw reduced
============================================================== */

const DPR = Math.min(window.devicePixelRatio, 1.75); // hard cap

const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);
camera.position.z = 6.4;

const LOCKED_ZOOM = 6.4;
let targetZoom = LOCKED_ZOOM;

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(DPR);
renderer.setSize(innerWidth, innerHeight);
renderer.autoClear = true;
container.appendChild(renderer.domElement);

/* ================= GALAXY (STATIC GEOMETRY) ================= */
const count = 18000;
const maxRadius = 7.2 * 0.9;
const pos = new Float32Array(count * 3);
const col = new Float32Array(count * 3);
for (let i = 0; i < count; i++) {
  const r = Math.random() * maxRadius;
  const a = Math.random() * Math.PI * 2;
  const i3 = i * 3;
  pos[i3]     = Math.cos(a) * r;
  pos[i3 + 1] = (Math.random() - 0.5) * 2;
  pos[i3 + 2] = Math.sin(a) * r;
  const c = new THREE.Color().setHSL(i / count, 1, 0.6);
  col[i3] = c.r; col[i3 + 1] = c.g; col[i3 + 2] = c.b;
}
const galaxyGeo = new THREE.BufferGeometry();
galaxyGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
galaxyGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));
const galaxyMat = new THREE.PointsMaterial({
  size: 0.02,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  transparent: true,
  depthWrite: false
});
const galaxy = new THREE.Points(galaxyGeo, galaxyMat);
galaxy.frustumCulled = false;
scene.add(galaxy);

/* ================= FALLING BINARY (CACHED TEXTURES) ================= */
const binGroup = new THREE.Group();
scene.add(binGroup);

const binSprites = [];
const binTextures = [];
for(let i=0;i<12;i++){
  const c=document.createElement('canvas'); c.width=32; c.height=32;
  const ctx=c.getContext('2d'); ctx.font='24px monospace';
  ctx.fillStyle=`hsl(${i*30},100%,60%)`; ctx.fillText(i%2?'1':'0',4,24);
  binTextures.push(new THREE.CanvasTexture(c));
}

for (let i = 0; i < 540; i++) {
  const tex = binTextures[i % binTextures.length];
  const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
  spr.position.set((Math.random()-0.5)*12, Math.random()*8+4, (Math.random()-0.5)*13);
  spr.scale.setScalar(0.32);
  spr.userData.speed = 0.01 + Math.random()*0.03;
  binGroup.add(spr);
  binSprites.push(spr);
}

/* ================= ELECTRONS (NO ALLOCATIONS PER FRAME) ================= */
const electronGroup = new THREE.Group();
scene.add(electronGroup);

const electrons = [];
const sphereGeo = new THREE.SphereGeometry(0.09, 16, 16);
const trailLen = 120;

function createElectron(){
  const mesh = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({transparent:true}));
  const arr = new Float32Array(trailLen * 3);
  const trailGeo = new THREE.BufferGeometry();
  trailGeo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
  const trail = new THREE.Line(trailGeo, new THREE.LineBasicMaterial({transparent:true,opacity:0.9}));
  electronGroup.add(mesh, trail);
  return {
    mesh, trail,
    angle: Math.random()*Math.PI*2,
    speed: (0.004+Math.random()*0.01)*2.25,
    ecc: 0.6+Math.random()*1.2,
    phase: Math.random()*Math.PI*2,
    timer: Math.random()*300
  };
}
for(let i=0;i<6;i++) electrons.push(createElectron());

/* ================= WIREFRAMES ================= */
const inner = new THREE.LineSegments(
  new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(2.8,2)),
  new THREE.LineBasicMaterial()
);
const outer = new THREE.LineSegments(
  new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(3.6,3)),
  new THREE.LineBasicMaterial()
);
inner.frustumCulled = outer.frustumCulled = false;
scene.add(inner, outer);

/* ================= BLACK HOLE ================= */
const blackHole = new THREE.Mesh(
  new THREE.SphereGeometry(0.9, 64, 64),
  new THREE.MeshBasicMaterial({ color:0x000000 })
);
scene.add(blackHole);

/* ================= HUD (LOW RES, LOW FPS) ================= */
const hudScene = new THREE.Scene();
const hudCam = new THREE.PerspectiveCamera(45,1,0.1,100);
hudCam.position.z = 4.5;
const hudGroup = new THREE.Group();
hudScene.add(hudGroup);

const mk=(s,o)=>new THREE.LineSegments(
  new THREE.WireframeGeometry(new THREE.BoxGeometry(s,s,s,o,o,o)),
  new THREE.LineBasicMaterial({transparent:true,opacity:o/6})
);
hudGroup.add(mk(1.8,6),mk(1.35,4),mk(0.9,2));

const hudRenderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
hudRenderer.setPixelRatio(1);
hudRenderer.setSize(220,220);
document.getElementById('hudWireframe').appendChild(hudRenderer.domElement);

/* ================= BUTTON ROUTING (LIGHTWEIGHT & SAFE) ================= */
const routes = {
  apply: '/apply/',
  WHY: '/WHY/',
  incorporate: '/incorporate/'
};

let navigating = false;

document.querySelectorAll('.pixel-button').forEach(btn => {
  btn.addEventListener('click', () => {
    if (navigating) return;
    navigating = true;

    const action = btn.dataset.action;
    const target = routes[action];

    // cinematic feedback
    targetZoom = 3.8;
    btn.style.filter = 'brightness(2)';

    setTimeout(() => {
      window.location.href = target;
    }, 420);
  });
});



/* ================= MAIN LOOP ================= */
let hue = 0;
let hudFrame = 0;

function animate(){
  requestAnimationFrame(animate);

  camera.position.z += (LOCKED_ZOOM - camera.position.z) * 0.08;

  galaxy.rotation.y += 0.0008;

  for(const s of binSprites){
    s.position.y -= s.userData.speed;
    if(s.position.y < -6) s.position.y = 6 + Math.random()*4;
  }

  for(const e of electrons){
    e.timer--;
    if(e.timer < 0){ e.timer = 200 + Math.random()*280; e.angle = Math.random()*Math.PI*2; }
    if(e.timer < 80){ e.mesh.visible = e.trail.visible = false; continue; }

    e.mesh.visible = e.trail.visible = true;
    e.angle += e.speed;

    const r = 3.8 + Math.sin(e.angle*e.ecc + e.phase) * 1.6;
    const x = Math.cos(e.angle) * r;
    const z = Math.sin(e.angle) * r;
    const y = Math.sin(e.angle*1.3) * 1.4;

    e.mesh.position.set(x,y,z);

    const arr = e.trail.geometry.attributes.position.array;
    arr.copyWithin(3,0,arr.length-3);
    arr[0]=x; arr[1]=y; arr[2]=z;
    e.trail.geometry.attributes.position.needsUpdate = true;
  }

  inner.rotation.y += 0.0025;
  outer.rotation.x += 0.0021;

  renderer.render(scene, camera);

  // HUD at ~30fps
  if((hudFrame++ & 1) === 0){
    hudGroup.rotation.x += 0.004;
    hudGroup.rotation.y += 0.006;
    hudGroup.rotation.z += 0.002;
    hudRenderer.render(hudScene, hudCam);
  }

  hue = (hue + 0.002) % 1;
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
