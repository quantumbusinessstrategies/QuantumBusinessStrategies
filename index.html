<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Business Strategies</title>

  <!-- =====================
       GLOBAL STYLES
       ===================== -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Silkscreen&display=swap" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Silkscreen', monospace;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #title {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(32px, 5vw, 48px);
      font-weight: bold;
      letter-spacing: -2px;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      text-shadow:
        0 0 8px #ff00ff,
        0 0 16px #00ffff,
        0 0 24px #ffff00,
        0 0 32px #ff00ff;
      filter: drop-shadow(0 0 6px #ff00ff);
      animation: rainbowShift 6s linear infinite;
    }

    #buttons {
      position: absolute;
      bottom: 96px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 18px;
      z-index: 10;
    }

    .arcade-btn {
  position: relative;
  width: 128px;
  height: 64px;
  cursor: pointer;
}
.arcade-btn svg { display:block; }
.arcade-btn span {
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:14px;
  pointer-events:none;
}
.arcade-btn svg rect {
  transition: transform 0.35s cubic-bezier(.2,.8,.2,1), opacity 0.25s ease, fill 0.6s linear;
}
@keyframes pixelDrift {
  0% { transform: translate(0,0); }
  50% { transform: translate(1px,-1px); }
  100% { transform: translate(0,0); }
}
.arcade-btn svg rect.drift {
  animation: pixelDrift 1.8s steps(2) infinite;
}
.arcade-btn.explode svg rect {
  transform: translate(var(--dx), var(--dy)) rotate(var(--rot));
  opacity: 0.6;
}

    #zoomControl {
      position: absolute;
      bottom: 16px;
      right: 16px;
      z-index: 20;
      background: rgba(0,0,0,0.45);
      padding: 10px;
      border-radius: 8px;
    }

    #hudWireframe {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 220px;
      height: 220px;
      pointer-events: none;
      z-index: 15;
    }

    @keyframes rainbowShift {
      0%   { color: #ff0000; }
      20%  { color: #ff00ff; }
      40%  { color: #00ffff; }
      60%  { color: #00ff00; }
      80%  { color: #ffff00; }
      100% { color: #ff0000; }
    }
  </style>

  <!-- =====================
       THREE IMPORT MAP
       ===================== -->
  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.164.0/build/three.module.js" } }
  </script>
</head>
<body>

  <!-- =====================
       UI LAYER
       ===================== -->
  <div id="container">
    <div id="hudWireframe"></div>

    <div id="zoomControl">
      <label style="color:white;font-size:12px">ZOOM</label><br />
      <input id="zoomSlider" type="range" min="3" max="14" step="0.1" value="6.4" />
    </div>

    <div id="title">QUANTUM BUSINESS STRATEGIES</div>

    <div id="buttons">
  <div class="arcade-btn" data-link="/apply"></div>
  <div class="arcade-btn" data-link="/why"></div>
  <div class="arcade-btn" data-link="/incorporate"></div>
</div>
  </div>
  </div>

  <!-- =====================
       MAIN MODULE
       ===================== -->
  <script type="module">
    // =====================
    // ARCADE BUTTONS (EXPLODE → RETURN)
    // =====================
    const BUTTON_COLS = 8;
    const BUTTON_ROWS = 4;
    const PIX = 16;

    document.querySelectorAll('.arcade-btn').forEach(btn => {
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', BUTTON_COLS * PIX);
      svg.setAttribute('height', BUTTON_ROWS * PIX);
      svg.setAttribute('viewBox', `0 0 ${BUTTON_COLS * PIX} ${BUTTON_ROWS * PIX}`);
      svg.style.overflow = 'visible';

      for (let y = 0; y < BUTTON_ROWS; y++) {
        for (let x = 0; x < BUTTON_COLS; x++) {
          const isCorner = (x === 0 && y === 0) || (x === BUTTON_COLS - 1 && y === 0) || (x === 0 && y === BUTTON_ROWS - 1) || (x === BUTTON_COLS - 1 && y === BUTTON_ROWS - 1);
          if (isCorner) continue;

          const r = document.createElementNS(svgNS, 'rect');
          r.setAttribute('x', x * PIX);
          r.setAttribute('y', y * PIX);
          r.setAttribute('width', PIX);
          r.setAttribute('height', PIX);
          r.setAttribute('fill', `hsl(${(x + y * BUTTON_COLS) * 25 % 360},100%,60%)`);

          const dx = (Math.random() - 0.5) * 48;
          const dy = (Math.random() - 0.5) * 48;
          const rot = (Math.random() - 0.5) * 40;
          r.style.setProperty('--dx', `${dx}px`);
          r.style.setProperty('--dy', `${dy}px`);
          r.style.setProperty('--rot', `${rot}deg`);

          r.classList.add('drift');
          svg.appendChild(r);
        }
      }

      const label = document.createElement('span');

      // beat-synced pixel hue shift
      let localHue = Math.random() * 360;
      let beat = 0;
      const BPM = 90; // arcade idle tempo
      const beatInterval = (60 / BPM) * 1000;

      setInterval(() => {
        beat++;
        // jump hue on beat (quantized), not continuous
        localHue = (localHue + 40) % 360;
        svg.querySelectorAll('rect').forEach((px, i) => {
          const offset = (i % 8) * 12;
          px.setAttribute(
            'fill',
            `hsl(${(localHue + offset) % 360}, 100%, ${beat % 2 === 0 ? 58 : 65}%)`
          );
        });
      }, beatInterval);
      label.textContent =
        btn.dataset.link === '/apply'
          ? 'APPLY'
          : btn.dataset.link === '/why'
          ? 'WHY'
          : 'INCORPORATE';

      btn.appendChild(svg);
      btn.appendChild(label);

      btn.addEventListener('click', () => {
        btn.classList.add('explode');
        setTimeout(() => btn.classList.remove('explode'), 420);
        setTimeout(() => window.location.href = btn.dataset.link, 520);
      });
    });


    import * as THREE from 'three';

    /* =========================================================
       CORE ENGINE SETUP
       ========================================================= */
    const container = document.getElementById('container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 6.4;

    let targetZoom = camera.position.z;
    document.getElementById('zoomSlider').addEventListener('input', e => {
      targetZoom = parseFloat(e.target.value);
    });

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    /* =========================================================
       GALAXY PARTICLES
       ========================================================= */
    function createGalaxy() {
      const count = 20000;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const r = Math.random() * 7.2;
        const a = Math.random() * Math.PI * 2;

        positions[i * 3]     = Math.cos(a) * r;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 2] = Math.sin(a) * r;

        const c = new THREE.Color().setHSL(i / count, 1.0, 0.6);
        colors[i * 3]     = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.02,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }

    const galaxy = createGalaxy();

    /* =========================================================
       FALLING BINARY MATRIX
       ========================================================= */
    const binGroup = new THREE.Group();
    scene.add(binGroup);
    const binSprites = [];

    function createBinarySprite() {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');

      ctx.font = '24px monospace';
      ctx.fillStyle = `hsl(${Math.random() * 360},100%,60%)`;
      ctx.fillText(Math.random() > 0.5 ? '1' : '0', 4, 24);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const spr = new THREE.Sprite(mat);

      spr.position.set(
        (Math.random() - 0.5) * 12,
        Math.random() * 8 + 4,
        (Math.random() - 0.5) * 13.2
      );
      spr.scale.set(0.315, 0.315, 0.315);
      spr.userData.speed = 0.01 + Math.random() * 0.03;

      binGroup.add(spr);
      binSprites.push(spr);
    }

    for (let i = 0; i < 600; i++) createBinarySprite();

    /* =========================================================
       QUANTUM ELECTRONS
       ========================================================= */
    const electronGroup = new THREE.Group();
    scene.add(electronGroup);

    function createElectron() {
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.0765, 16, 16),
        new THREE.MeshBasicMaterial({ transparent: true })
      );

      const trailLen = 160;
      const trailPos = new Float32Array(trailLen * 3);
      const trailGeo = new THREE.BufferGeometry();
      trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));

      const trail = new THREE.Line(
        trailGeo,
        new THREE.LineBasicMaterial({ transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending, linewidth: 2 })
      );

      electronGroup.add(mesh, trail);

      return {
        mesh,
        trail,
        angle: Math.random() * Math.PI * 2,
        speed: (0.004 + Math.random() * 0.008) * 3,
        ecc: 0.4 + Math.random() * 1.2,
        phase: Math.random() * Math.PI * 2,
        visibleTimer: Math.random() * 360
      };
    }

    const electrons = Array.from({ length: 6 }, createElectron);

    const ELECTRON_SPEED_MULTIPLIER = 3.75;

    /* =========================================================
       CENTRAL WIREFRAMES
       ========================================================= */
    const innerWire = new THREE.LineSegments(
      new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(2.8, 2)),
      new THREE.LineBasicMaterial()
    );

    const outerWire = new THREE.LineSegments(
      new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(3.6, 3)),
      new THREE.LineBasicMaterial()
    );

    innerWire.scale.setScalar(0.9);
    outerWire.scale.setScalar(0.9);
    scene.add(innerWire, outerWire);

    /* =========================================================
       HUD WIREFRAME
       ========================================================= */
    const hudScene = new THREE.Scene();
    const hudCam = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    hudCam.position.z = 4.5;

    const hudGroup = new THREE.Group();
    hudScene.add(hudGroup);

    const hudBoxes = [
      new THREE.BoxGeometry(1.8, 1.8, 1.8, 6, 6, 6),
      new THREE.BoxGeometry(1.35, 1.35, 1.35, 4, 4, 4),
      new THREE.BoxGeometry(0.9, 0.9, 0.9, 2, 2, 2)
    ].map((geo, i) => new THREE.LineSegments(
      new THREE.WireframeGeometry(geo),
      new THREE.LineBasicMaterial({ transparent: true, opacity: 1 - i * 0.2 })
    ));

    hudBoxes.forEach(b => hudGroup.add(b));

    const hudRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    hudRenderer.setSize(220, 220);
    document.getElementById('hudWireframe').appendChild(hudRenderer.domElement);

    /* =========================================================
       BLACK HOLE LENS
       ========================================================= */
    const rt = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

    const warpScene = new THREE.Scene();
    const warpCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const warpMat = new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        strength: { value: 1.287 }
      },
      vertexShader: `varying vec2 vUv; void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float strength;
        varying vec2 vUv;
        void main(){
          vec2 c = vec2(0.5);
          vec2 d = vUv - c;
          float r = length(d);
          float h = 0.054;
          float shell = smoothstep(h*1.7, h, r);
          float warp = strength * shell / max(r, h);
          vec2 uv = c + normalize(d) * (r - warp * 0.25);
          vec4 col = texture2D(tDiffuse, uv);
          col.rgb *= smoothstep(h*0.9, h, r);
          gl_FragColor = col;
        }
      `
    });

    warpScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), warpMat));

    /* =========================================================
       ANIMATION LOOP
       ========================================================= */
    let hue = 0;

    function animate() {
      requestAnimationFrame(animate);
      try {
        camera.position.z += (targetZoom - camera.position.z) * 0.08;

        galaxy.rotation.y += 0.0008;

        binSprites.forEach(s => {
          s.position.y -= s.userData.speed;
          if (s.position.y < -6) s.position.y = 6 + Math.random() * 4;
        });

        electrons.forEach(e => {
          e.visibleTimer--;
          if (e.visibleTimer <= 0) {
            e.visibleTimer = 120 + Math.random() * 320;
            e.angle = Math.random() * Math.PI * 2;
          }
          const visible = e.visibleTimer > 30;
          e.mesh.visible = e.trail.visible = visible;
          if (!visible) return;

          e.angle += e.speed * ELECTRON_SPEED_MULTIPLIER;
          const r = 3.4 + Math.sin(e.angle * e.ecc + e.phase) * 1.4;
          const x = Math.cos(e.angle) * r;
          const z = Math.sin(e.angle * 0.9) * r;
          const y = Math.sin(e.angle * 1.3) * 1.4;

          e.mesh.position.set(x, y, z);
          e.mesh.material.opacity = 0.5 + Math.random() * 0.5;
          e.mesh.material.color.setHSL(hue, 1, 0.7);

          const arr = e.trail.geometry.attributes.position.array;
          for (let i = arr.length - 3; i >= 3; i--) {
            arr[i] = arr[i - 3] * 0.985;
          }
          arr[0] = x; arr[1] = y; arr[2] = z;
          e.trail.geometry.attributes.position.needsUpdate = true;
          e.trail.material.opacity = 0.35 + e.speed * 4.5;
          e.trail.material.color.setHSL((hue + 0.15) % 1, 1, 0.55);
        });

        innerWire.rotation.y += 0.0015;
        outerWire.rotation.x += 0.0012;

        hue = (hue + 0.002) % 1;

        innerWire.material.color.setHSL(hue, 1, 0.6);
        outerWire.material.color.setHSL((hue + 0.5) % 1, 1, 0.6);

        hudGroup.rotation.x += 0.002;
        hudGroup.rotation.y += 0.003;
        hudBoxes.forEach((b, i) => b.material.color.setHSL((hue + i * 0.2) % 1, 1, 0.6));

        hudRenderer.render(hudScene, hudCam);

        renderer.setRenderTarget(rt);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);

        warpMat.uniforms.tDiffuse.value = rt.texture;
        renderer.render(warpScene, warpCam);
      } catch (err) {
        console.error('Render loop error:', err);
        if (!document.getElementById('renderError')) {
          const div = document.createElement('div');
          div.id = 'renderError';
          div.style.position = 'fixed';
          div.style.bottom = '12px';
          div.style.left = '12px';
          div.style.padding = '8px 12px';
          div.style.background = 'rgba(255,0,0,0.75)';
          div.style.color = '#fff';
          div.style.fontSize = '12px';
          div.style.zIndex = '9999';
          div.textContent = 'Render paused — check console';
          document.body.appendChild(div);
        }
      }
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      rt.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
